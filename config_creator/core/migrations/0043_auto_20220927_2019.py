# Generated by Django 4.0.5 on 2022-09-27 19:19

from django.db import migrations


def addfunctiontypes(apps, schema_editor):
    model = apps.get_model("core", "FunctionType")

    if not model.objects.filter(
        name="STRING",
    ).exists():
        model(
            name="STRING",
        ).save()

    if not model.objects.filter(
        name="ARRAY",
    ).exists():
        model(
            name="ARRAY",
        ).save()

    if not model.objects.filter(
        name="BIT",
    ).exists():
        model(
            name="BIT",
        ).save()

    if not model.objects.filter(
        name="CONVERSION",
    ).exists():
        model(
            name="CONVERSION",
        ).save()

    if not model.objects.filter(
        name="DATE",
    ).exists():
        model(
            name="DATE",
        ).save()

    if not model.objects.filter(
        name="DATETIME",
    ).exists():
        model(
            name="DATETIME",
        ).save()

    if not model.objects.filter(
        name="HASH",
    ).exists():
        model(
            name="HASH",
        ).save()

    if not model.objects.filter(
        name="INTERVAL",
    ).exists():
        model(
            name="INTERVAL",
        ).save()

    if not model.objects.filter(
        name="JSON",
    ).exists():
        model(
            name="JSON",
        ).save()

    if not model.objects.filter(
        name="MATHS",
    ).exists():
        model(
            name="MATHS",
        ).save()

    if not model.objects.filter(
        name="TIME",
    ).exists():
        model(
            name="TIME",
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP",
    ).exists():
        model(
            name="TIMESTAMP",
        ).save()

    if not model.objects.filter(
        name="UTILITY",
    ).exists():
        model(
            name="UTILITY",
        ).save()

    if not model.objects.filter(
        name="CONDITIONAL",
    ).exists():
        model(
            name="CONDITIONAL",
        ).save()


def adddatatypes(apps, schema_editor):
    model = apps.get_model("core", "BigQueryDataType")

    if not model.objects.filter(
        name="BYTES",
    ).exists():
        model(
            name="BYTES",
            description="Variable-length binary data",
        ).save()

    if not model.objects.filter(
        name="ARRAY",
    ).exists():
        model(
            name="ARRAY",
            description="Ordered list of zero or more elements of any non-ARRAY type.",
        ).save()

    if not model.objects.filter(
        name="GEOGRAPHY",
    ).exists():
        model(
            name="GEOGRAPHY",
            description="A collection of points, lines, and polygons, which is represented as a point set, or a subset of the surface of the Earth.",
        ).save()

    if not model.objects.filter(
        name="INTERVAL",
    ).exists():
        model(
            name="INTERVAL",
            description="An INTERVAL object represents duration or amount of time.",
        ).save()

    if not model.objects.filter(
        name="JSON",
    ).exists():
        model(
            name="JSON",
            description="Represents JSON, a lightweight data-interchange format.",
        ).save()

    if not model.objects.filter(
        name="STRUCT",
    ).exists():
        model(
            name="STRUCT",
            description="Container of ordered fields each with a type (required) and field name (optional).",
        ).save()

    if not model.objects.filter(
        name="TIME",
    ).exists():
        model(
            name="TIME",
            description="A TIME value represents a time of day, as might be displayed on a clock, independent of a specific date and time zone.",
        ).save()

    if not model.objects.filter(
        name="BIGNUMERIC",
    ).exists():
        model(
            name="BIGNUMERIC",
            description="",
        ).save()

    if not model.objects.filter(
        name="DATETIME",
    ).exists():
        model(
            name="DATETIME",
            description="A DATETIME value represents a date and time, as they might be displayed on a watch, independent of time zone. It includes the year, month, day, hour, minute, second, and subsecond.",
        ).save()

    if model.objects.filter(
        name="BOOLEAN",
    ).exists():
        indb = model.objects.get(
            name="BOOLEAN",
        )
        indb.name = "BOOL"
        indb.save()


def addfunction(apps, schema_editor):
    model = apps.get_model("core", "Function")

    if not model.objects.filter(
        name="ASCII",
    ).exists():
        model(
            name="ASCII",
            syntax="ASCII(value)",
            description="Returns the ASCII code for the first character or byte in value. Returns 0 if value is empty or the ASCII code is 0 for the first character or byte.",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="BYTE_LENGTH",
    ).exists():
        model(
            name="BYTE_LENGTH",
            syntax="BYTE_LENGTH(value)",
            description="Returns the length of the STRING or BYTES value in BYTES, regardless of whether the type of the value is STRING or BYTES.",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CHAR_LENGTH",
    ).exists():
        model(
            name="CHAR_LENGTH",
            syntax="CHAR_LENGTH(value)",
            description="Returns the length of the STRING in characters.",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CHR",
    ).exists():
        model(
            name="CHR",
            syntax="CHR(value)",
            description="""Takes a Unicode code point and returns the character that matches the code point. Each valid code point should fall within the range of [0, 0xD7FF] and [0xE000, 0x10FFFF]. Returns an empty string if the code point is 0. If an invalid Unicode code point is specified, an error is returned.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="CODE_POINTS_TO_BYTES",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="CODE_POINTS_TO_BYTES",
            syntax="CODE_POINTS_TO_BYTES(value)",
            description="""Takes an array of extended ASCII code points (ARRAY of INT64) and returns BYTES.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="CODE_POINTS_TO_STRING",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="CODE_POINTS_TO_STRING",
            syntax="CODE_POINTS_TO_STRING(value)",
            description="""Takes an array of Unicode code points (ARRAY of INT64) and returns a STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="COLLATE",
    ).exists():
        model(
            name="COLLATE",
            syntax="COLLATE(value, collate_specification)",
            description="""Takes a STRING and a collation specification. Returns a STRING with a collation specification. If collate_specification is empty, returns a value with collation removed from the STRING.

The collation specification defines how the resulting STRING can be compared and sorted.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="CONCAT",
    ).exists():
        model(
            name="CONCAT",
            syntax="CONCAT(value1[, ...])",
            description="""Concatenates one or more values into a single result. All values must be BYTES or data types that can be cast to STRING.

The function returns NULL if any input argument is NULL.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="CONTAINS_SUBSTR",
    ).exists():
        model(
            name="CONTAINS_SUBSTR",
            syntax="CONTAINS_SUBSTR(expression, search_value_literal)",
            description="""Performs a normalized, case-insensitive search to see if a value exists in an expression. Returns TRUE if the value exists, otherwise returns FALSE.

The search value must be a STRING literal, but not the literal NULL.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="ENDS_WITH",
    ).exists():
        model(
            name="ENDS_WITH",
            syntax="ENDS_WITH(value1, value2)",
            description="""Takes two STRING or BYTES values. Returns TRUE if the second value is a suffix of the first.

This function supports specifying collation.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="FORMAT",
    ).exists():
        model(
            name="FORMAT",
            syntax="FORMAT(format_string_expression, data_type_expression[, ...])",
            description="""FORMAT formats a data type expression as a string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_BASE32",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="FROM_BASE32",
            syntax="FROM_BASE32(string_expr)",
            description="""Converts the base32-encoded input string_expr into BYTES format.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_BASE32",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="FROM_BASE32",
            syntax="FROM_BASE32(string_expr)",
            description="""Converts the base32-encoded input string_expr into BYTES format.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_BASE64",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="FROM_BASE64",
            syntax="FROM_BASE64(string_expr)",
            description="""Converts the base64-encoded input string_expr into BYTES format.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_BASE64",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="FROM_BASE64",
            syntax="FROM_BASE64(string_expr)",
            description="""Converts the base64-encoded input string_expr into BYTES format.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_HEX",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="FROM_HEX",
            syntax="FROM_HEX(string)",
            description="""Converts a hexadecimal-encoded STRING into BYTES format. Returns an error if the input STRING contains characters outside the range (0..9, A..F, a..f). The lettercase of the characters does not matter. If the input STRING has an odd number of characters, the function acts as if the input has an additional leading 0.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="FROM_HEX",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="FROM_HEX",
            syntax="FROM_HEX(string)",
            description="""Converts a hexadecimal-encoded STRING into BYTES format. Returns an error if the input STRING contains characters outside the range (0..9, A..F, a..f). The lettercase of the characters does not matter. If the input STRING has an odd number of characters, the function acts as if the input has an additional leading 0.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="INITCAP",
    ).exists():
        model(
            name="INITCAP",
            syntax="INITCAP(value[, delimiters])",
            description="""Takes a STRING and returns it with the first character in each word in uppercase and all other characters in lowercase. Non-alphabetic characters remain the same.

delimiters is an optional string argument that is used to override the default set of characters used to separate words. If delimiters is not specified, it defaults to the following characters:
<whitespace> [ ] ( ) { } / | \ < > ! ? @ " ^ # $ & ~ _ , . : ; * % + -

If value or delimiters is NULL, the function returns NULL.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="INSTR",
    ).exists():
        model(
            name="INSTR",
            syntax="INSTR(source_value, search_value[, position[, occurrence]])",
            description="""Returns the lowest 1-based index of search_value in source_value. 0 is returned when no match is found. source_value and search_value must be the same type, either STRING or BYTES.

If position is specified, the search starts at this position in source_value, otherwise it starts at the beginning of source_value. If position is negative, the function searches backwards from the end of source_value, with -1 indicating the last character. position cannot be 0.

If occurrence is specified, the search returns the position of a specific instance of search_value in source_value, otherwise it returns the index of the first occurrence. If occurrence is greater than the number of matches found, 0 is returned. For occurrence > 1, the function searches for overlapping occurrences, in other words, the function searches for additional occurrences beginning with the second character in the previous occurrence. occurrence cannot be 0 or negative.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LEFT",
    ).exists():
        model(
            name="LEFT",
            syntax="LEFT(value, length)",
            description="""Returns a STRING value that consists of the specified number of leftmost characters from value. The length is an INT64 that specifies the length of the returned value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="LENGTH",
    ).exists():
        model(
            name="LENGTH",
            syntax="LENGTH(value)",
            description="""Returns the length of the STRING or BYTES value. The returned value is in characters for STRING arguments and in bytes for the BYTES argument.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LPAD",
    ).exists():
        model(
            name="LPAD",
            syntax="LPAD(original_value, return_length[, pattern])",
            description="""Returns a STRING value that consists of original_value prepended with pattern. The return_length is an INT64 that specifies the length of the returned value.

The default value of pattern is a blank space.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="LOWER",
    ).exists():
        model(
            name="LOWER",
            syntax="LOWER(value)",
            description="""Returns the original string with all alphabetic characters in lowercase.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="LTRIM",
    ).exists():
        model(
            name="LTRIM",
            syntax="LTRIM(value1[, value2])",
            description="""Removes leading characters.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="NORMALIZE",
    ).exists():
        model(
            name="NORMALIZE",
            syntax="NORMALIZE(value[, normalization_mode])",
            description="""Takes a string value and returns it as a normalized string. If you do not provide a normalization mode, NFC is used.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="NORMALIZE_AND_CASEFOLD",
    ).exists():
        model(
            name="NORMALIZE_AND_CASEFOLD",
            syntax="NORMALIZE_AND_CASEFOLD(value[, normalization_mode])",
            description="""Takes a string value and returns it as a normalized string. If you do not provide a normalization mode, NFC is used.

Case folding is used for the caseless comparison of strings.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="REGEXP_CONTAINS",
    ).exists():
        model(
            name="REGEXP_CONTAINS",
            syntax="REGEXP_CONTAINS(value, regexp)",
            description="""Returns TRUE if value is a partial match for the regular expression, regexp.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="REGEXP_EXTRACT",
    ).exists():
        model(
            name="REGEXP_EXTRACT",
            syntax="REGEXP_EXTRACT(value, regexp[, position[, occurrence]])",
            description="""Returns the substring in value that matches the regular expression, regexp. Returns NULL if there is no match.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="REGEXP_EXTRACT_ALL",
    ).exists():
        model(
            name="REGEXP_EXTRACT_ALL",
            syntax="REGEXP_EXTRACT_ALL(value, regexp)",
            description="""Returns an array of all substrings of value that match the regular expression, regexp.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="REGEXP_INSTR",
    ).exists():
        model(
            name="REGEXP_INSTR",
            syntax="REGEXP_INSTR(source_value, regexp [, position[, occurrence, [occurrence_position]]])",
            description="""Returns the lowest 1-based index of a regular expression, regexp, in source_value. Returns 0 when no match is found or the regular expression is empty.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="REGEXP_REPLACE",
    ).exists():
        model(
            name="REGEXP_REPLACE",
            syntax="REGEXP_REPLACE(value, regexp, replacement)",
            description="""Returns a STRING where all substrings of value that match regular expression regexp are replaced with replacement.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="REPLACE",
    ).exists():
        model(
            name="REPLACE",
            syntax="REPLACE(original_value, from_value, to_value)",
            description="""Replaces all occurrences of from_value with to_value in original_value. If from_value is empty, no replacement is made.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="REPEAT",
    ).exists():
        model(
            name="REPEAT",
            syntax="REPEAT(original_value, repetitions)",
            description="""Replaces all occurrences of from_value with to_value in original_value. If from_value is empty, no replacement is made.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="REVERSE",
    ).exists():
        model(
            name="REVERSE",
            syntax="REVERSE(value)",
            description="""Returns the reverse of the input STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="RIGHT",
    ).exists():
        model(
            name="RIGHT",
            syntax="RIGHT(value, length)",
            description="""Returns a STRING value that consists of the specified number of rightmost characters or bytes from value. The length is an INT64 that specifies the length of the returned value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="RPAD",
    ).exists():
        model(
            name="RPAD",
            syntax="RPAD(original_value, return_length[, pattern])",
            description="""Returns a STRING value that consists of original_value appended with pattern. The return_length parameter is an INT64 that specifies the length of the returned value.

The default value of pattern is a blank space.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="RTRIM",
    ).exists():
        model(
            name="RTRIM",
            syntax="RTRIM(value1[, value2])",
            description="""Removes trailing characters.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CONVERT_BYTES_TO_STRING",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="SAFE_CONVERT_BYTES_TO_STRING",
            syntax="SAFE_CONVERT_BYTES_TO_STRING(value)",
            description="""Converts a sequence of BYTES to a STRING. Any invalid UTF-8 characters are replaced with the Unicode replacement character, U+FFFD.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CONVERT_BYTES_TO_STRING",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="SAFE_CONVERT_BYTES_TO_STRING",
            syntax="SAFE_CONVERT_BYTES_TO_STRING(value)",
            description="""Converts a sequence of BYTES to a STRING. Any invalid UTF-8 characters are replaced with the Unicode replacement character, U+FFFD.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SOUNDEX",
    ).exists():
        model(
            name="SOUNDEX",
            syntax="SOUNDEX(value)",
            description="""Returns a STRING that represents the Soundex code for value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SPLIT",
    ).exists():
        model(
            name="SPLIT",
            syntax="SPLIT(value[, delimiter])",
            description="""Splits value using the delimiter argument.

The default delimiter is the comma ,.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="STARTS_WITH",
    ).exists():
        model(
            name="STARTS_WITH",
            syntax="STARTS_WITH(value1, value2)",
            description="""Takes two STRING values. Returns TRUE if the second value is a prefix of the first.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="STRPOS",
    ).exists():
        model(
            name="STRPOS",
            syntax="STRPOS(value1, value2)",
            description="""Takes two STRING values. Returns the 1-based index of the first occurrence of value2 inside value1. Returns 0 if value2 is not found.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SUBSTR",
    ).exists():
        model(
            name="SUBSTR",
            syntax="SUBSTR(value, position[, length])",
            description="""Returns a substring of the supplied STRING value.

The position argument is an integer specifying the starting position of the substring.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_BASE32",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="TO_BASE32",
            syntax="TO_BASE32(bytes_expr)",
            description="""Converts a sequence of BYTES into a base32-encoded STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_BASE64",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="TO_BASE64",
            syntax="TO_BASE64(bytes_expr)",
            description="""Converts a sequence of BYTES into a base64-encoded STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_BASE32",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="TO_BASE32",
            syntax="TO_BASE32(bytes_expr)",
            description="""Converts a sequence of BYTES into a base32-encoded STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_BASE64",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="TO_BASE64",
            syntax="TO_BASE64(bytes_expr)",
            description="""Converts a sequence of BYTES into a base64-encoded STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_CODE_POINTS",
    ).exists():
        model(
            name="TO_CODE_POINTS",
            syntax="TO_CODE_POINTS(value)",
            description="""Takes a value and returns an array of INT64.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_HEX",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="TO_HEX",
            syntax="TO_HEX(bytes)",
            description="""Converts a sequence of BYTES into a hexadecimal STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_HEX",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="TO_HEX",
            syntax="TO_HEX(bytes)",
            description="""Converts a sequence of BYTES into a hexadecimal STRING.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_JSON",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="TO_JSON",
            syntax="TO_JSON(sql_value[, stringify_wide_numbers=>{ TRUE | FALSE }])",
            description="""Takes a SQL value and returns a JSON value. The value must be a supported BigQuery data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_JSON_STRING",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="TO_JSON_STRING",
            syntax="TO_JSON_STRING(value[, pretty_print])",
            description="""Takes a SQL value and returns a JSON-formatted string representation of the value. The value must be a supported BigQuery data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_JSON",
        type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
    ).exists():
        model(
            name="TO_JSON",
            syntax="TO_JSON(sql_value[, stringify_wide_numbers=>{ TRUE | FALSE }])",
            description="""Takes a SQL value and returns a JSON value. The value must be a supported BigQuery data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="TO_JSON_STRING",
        type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
    ).exists():
        model(
            name="TO_JSON_STRING",
            syntax="TO_JSON_STRING(value[, pretty_print])",
            description="""Takes a SQL value and returns a JSON-formatted string representation of the value. The value must be a supported BigQuery data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TRANSLATE",
    ).exists():
        model(
            name="TRANSLATE",
            syntax="TRANSLATE(expression, source_characters, target_characters)",
            description="""In expression, replaces each character in source_characters with the corresponding character in target_characters.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TRIM",
    ).exists():
        model(
            name="TRIM",
            syntax="TRIM(value_to_trim[, set_of_characters_to_remove])",
            description="""Takes a STRING value to trim.

Removes from this value all leading and trailing Unicode code points in set_of_characters_to_remove. The set of code points is optional. If it is not specified, all whitespace characters are removed from the beginning and end of the value to trim.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="UNICODE",
    ).exists():
        model(
            name="UNICODE",
            syntax="UNICODE(value)",
            description="""Returns the Unicode code point for the first character in value. Returns 0 if value is empty, or if the resulting Unicode code point is 0.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="UPPER",
    ).exists():
        model(
            name="UPPER",
            syntax="UPPER(value)",
            description="""Returns the original string with all alphabetic characters in uppercase.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY",
    ).exists():
        model(
            name="ARRAY",
            syntax="ARRAY(subquery)",
            description="""The ARRAY function returns an ARRAY with one element for each row in a subquery.

If subquery produces a SQL table, the table must have exactly one column. Each element in the output ARRAY is the value of the single column of a row in the table.

If subquery produces a value table, then each element in the output ARRAY is the entire corresponding row of the value table.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY_CONCAT",
    ).exists():
        model(
            name="ARRAY_CONCAT",
            syntax="ARRAY_CONCAT(array_expression[, ...])",
            description="""Concatenates one or more arrays with the same element type into a single array.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY_LENGTH",
    ).exists():
        model(
            name="ARRAY_LENGTH",
            syntax="ARRAY_LENGTH(array_expression)",
            description="""Returns the size of the array. Returns 0 for an empty array. Returns NULL if the array_expression is NULL.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY_TO_STRING",
    ).exists():
        model(
            name="ARRAY_TO_STRING",
            syntax="ARRAY_TO_STRING(array_expression, delimiter[, null_text])",
            description="""Returns a concatenation of the elements in array_expression as a STRING. The value for array_expression can either be an array of STRING or BYTES data types.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY_TO_STRING",
    ).exists():
        model(
            name="ARRAY_TO_STRING",
            syntax="ARRAY_TO_STRING(array_expression, delimiter[, null_text])",
            description="""Returns a concatenation of the elements in array_expression as a STRING. The value for array_expression can either be an array of STRING or BYTES data types.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="GENERATE_ARRAY",
    ).exists():
        model(
            name="GENERATE_ARRAY",
            syntax="GENERATE_ARRAY(start_expression, end_expression[, step_expression])",
            description="""Returns an array of values. The start_expression and end_expression parameters determine the inclusive start and end of the array.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="GENERATE_DATE_ARRAY",
    ).exists():
        model(
            name="GENERATE_DATE_ARRAY",
            syntax="GENERATE_DATE_ARRAY(start_date, end_date[, INTERVAL INT64_expr date_part])",
            description="""Returns an array of dates. The start_date and end_date parameters determine the inclusive start and end of the array.

The GENERATE_DATE_ARRAY function accepts the following data types as inputs:

start_date must be a DATE
end_date must be a DATE
INT64_expr must be an INT64
date_part must be either DAY, WEEK, MONTH, QUARTER, or YEAR.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="GENERATE_TIMESTAMP_ARRAY",
    ).exists():
        model(
            name="GENERATE_TIMESTAMP_ARRAY",
            syntax="GENERATE_TIMESTAMP_ARRAY(start_timestamp, end_timestamp, INTERVAL step_expression date_part)",
            description="""Returns an ARRAY of TIMESTAMPS separated by a given interval. The start_timestamp and end_timestamp parameters determine the inclusive lower and upper bounds of the ARRAY.

The GENERATE_TIMESTAMP_ARRAY function accepts the following data types as inputs:

start_timestamp: TIMESTAMP
end_timestamp: TIMESTAMP
step_expression: INT64
Allowed date_part values are: MICROSECOND, MILLISECOND, SECOND, MINUTE, HOUR, or DAY.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="ARRAY_REVERSE",
    ).exists():
        model(
            name="ARRAY_REVERSE",
            syntax="ARRAY_REVERSE(value)",
            description="""Returns the input ARRAY with elements in reverse order.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="ARRAY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="BIT_COUNT",
    ).exists():
        model(
            name="BIT_COUNT",
            syntax="BIT_COUNT(expression)",
            description="""Returns the number of bits that are set in the input expression. For signed integers, this is the number of bits in two's complement form.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="BIT"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS ARRAY",
    ).exists():
        model(
            name="CAST AS ARRAY",
            syntax="CAST(expression AS ARRAY<element_type>)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

BigQuery supports casting to ARRAY.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS INT64",
    ).exists():
        model(
            name="CAST AS INT64",
            syntax="CAST(expression AS INT64)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS FLOAT64",
    ).exists():
        model(
            name="CAST AS FLOAT64",
            syntax="CAST(expression AS FLOAT64)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS NUMERIC",
    ).exists():
        model(
            name="CAST AS NUMERIC",
            syntax="CAST(expression AS NUMERIC)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="NUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS BIGNUMERIC",
    ).exists():
        model(
            name="CAST AS BIGNUMERIC",
            syntax="CAST(expression AS BIGNUMERIC)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BIGNUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS STRING",
    ).exists():
        model(
            name="CAST AS STRING",
            syntax="CAST(expression AS STRING)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS BOOL",
    ).exists():
        model(
            name="CAST AS BOOL",
            syntax="CAST(expression AS BOOL)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS BYTES",
    ).exists():
        model(
            name="CAST AS BYTES",
            syntax="CAST(expression AS BYTES)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS DATE",
    ).exists():
        model(
            name="CAST AS DATE",
            syntax="CAST(expression AS DATE)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS DATETIME",
    ).exists():
        model(
            name="CAST AS DATETIME",
            syntax="CAST(expression AS DATETIME)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS INTERVAL",
    ).exists():
        model(
            name="CAST AS INTERVAL",
            syntax="CAST(expression AS INTERVAL)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS STRUCT",
    ).exists():
        model(
            name="CAST AS STRUCT",
            syntax="CAST(expression AS STRUCT)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRUCT"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS TIME",
    ).exists():
        model(
            name="CAST AS TIME",
            syntax="CAST(expression AS TIME)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="CAST AS TIMESTAMP",
    ).exists():
        model(
            name="CAST AS TIMESTAMP",
            syntax="CAST(expression AS TIMESTAMP)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS ARRAY",
    ).exists():
        model(
            name="SAFE_CAST AS ARRAY",
            syntax="SAFE_CAST(expression AS ARRAY<element_type>)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.

BigQuery supports casting to ARRAY.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS INT64",
    ).exists():
        model(
            name="SAFE_CAST AS INT64",
            syntax="SAFE_CAST(expression AS INT64)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS FLOAT64",
    ).exists():
        model(
            name="SAFE_CAST AS FLOAT64",
            syntax="SAFE_CAST(expression AS FLOAT64)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS NUMERIC",
    ).exists():
        model(
            name="SAFE_CAST AS NUMERIC",
            syntax="SAFE_CAST(expression AS NUMERIC)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="NUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS BIGNUMERIC",
    ).exists():
        model(
            name="SAFE_CAST AS BIGNUMERIC",
            syntax="SAFE_CAST(expression AS BIGNUMERIC)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BIGNUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS STRING",
    ).exists():
        model(
            name="SAFE_CAST AS STRING",
            syntax="SAFE_CAST(expression AS STRING)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS BOOL",
    ).exists():
        model(
            name="SAFE_CAST AS BOOL",
            syntax="SAFE_CAST(expression AS BOOL)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS BYTES",
    ).exists():
        model(
            name="SAFE_CAST AS BYTES",
            syntax="SAFE_CAST(expression AS BYTES)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS DATE",
    ).exists():
        model(
            name="SAFE_CAST AS DATE",
            syntax="SAFE_CAST(expression AS DATE)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS DATETIME",
    ).exists():
        model(
            name="SAFE_CAST AS DATETIME",
            syntax="SAFE_CAST(expression AS DATETIME)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS INTERVAL",
    ).exists():
        model(
            name="SAFE_CAST AS INTERVAL",
            syntax="SAFE_CAST(expression AS INTERVAL)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS STRUCT",
    ).exists():
        model(
            name="SAFE_CAST AS STRUCT",
            syntax="SAFE_CAST(expression AS STRUCT)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRUCT"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS TIME",
    ).exists():
        model(
            name="SAFE_CAST AS TIME",
            syntax="SAFE_CAST(expression AS TIME)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_CAST AS TIMESTAMP",
    ).exists():
        model(
            name="SAFE_CAST AS TIMESTAMP",
            syntax="SAFE_CAST(expression AS TIMESTAMP)",
            description="""Cast syntax is used in a query to indicate that the result type of an expression should be converted to some other type.

SAFE_CAST is identical to SELF_CAST, except it returns NULL instead of raising an error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_BIGNUMERIC",
    ).exists():
        model(
            name="PARSE_BIGNUMERIC",
            syntax="PARSE_BIGNUMERIC(string_expression)",
            description="""Converts a string to a BIGNUMERIC value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BIGNUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_NUMERIC",
    ).exists():
        model(
            name="PARSE_NUMERIC",
            syntax="PARSE_NUMERIC(string_expression)",
            description="""Converts a string to a NUMERIC value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="NUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_DATE",
    ).exists():
        model(
            name="PARSE_DATE",
            syntax="PARSE_DATE(string_expression)",
            description="""Converts a string to a DATE value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_DATETIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="PARSE_DATETIME",
            syntax="PARSE_DATETIME(string_expression)",
            description="""Converts a string to a DATETIME value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_DATETIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
    ).exists():
        model(
            name="PARSE_DATETIME",
            syntax="PARSE_DATETIME(string_expression)",
            description="""Converts a string to a DATETIME value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_JSON",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="PARSE_JSON",
            syntax="PARSE_JSON(string_expression)",
            description="""Converts a string to a JSON value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_JSON",
        type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
    ).exists():
        model(
            name="PARSE_JSON",
            syntax="PARSE_JSON(string_expression)",
            description="""Converts a string to a JSON value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_TIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="PARSE_TIME",
            syntax="PARSE_TIME(string_expression)",
            description="""Converts a string to a TIME value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_TIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="PARSE_TIME",
            syntax="PARSE_TIME(string_expression)",
            description="""Converts a string to a TIME value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_TIMESTAMP",
        type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
    ).exists():
        model(
            name="PARSE_TIMESTAMP",
            syntax="PARSE_TIMESTAMP(string_expression)",
            description="""Converts a string to a TIMESTAMP value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONVERSION"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_TIMESTAMP",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="PARSE_TIMESTAMP",
            syntax="PARSE_TIMESTAMP(string_expression)",
            description="""Converts a string to a TIMESTAMP value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="CURRENT_DATE",
    ).exists():
        model(
            name="CURRENT_DATE",
            syntax="CURRENT_DATE([time_zone])",
            description="""Returns the current date as of the specified or default time zone. Parentheses are optional when called with no arguments.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="CURRENT_DATETIME",
    ).exists():
        model(
            name="CURRENT_DATETIME",
            syntax="CURRENT_DATETIME([time_zone])",
            description="""Returns the current time as a DATETIME object. Parentheses are optional when called with no arguments.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="CURRENT_TIME",
    ).exists():
        model(
            name="CURRENT_TIME",
            syntax="CURRENT_TIME([time_zone])",
            description="""Returns the current time as a TIME object. Parentheses are optional when called with no arguments.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="CURRENT_TIMESTAMP",
    ).exists():
        model(
            name="CURRENT_TIMESTAMP",
            syntax="CURRENT_TIMESTAMP([time_zone])",
            description="""CURRENT_TIMESTAMP() produces a TIMESTAMP value that is continuous, non-ambiguous, has exactly 60 seconds per minute and does not repeat values over the leap second. Parentheses are optional.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="EXTRACT",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
    ).exists():
        model(
            name="EXTRACT",
            syntax="EXTRACT(part FROM date_expression)",
            description="""Returns the value corresponding to the specified date part. The part must be one of:

DAYOFWEEK: Returns values in the range [1,7] with Sunday as the first day of the week.
DAY
DAYOFYEAR
WEEK: Returns the week number of the date in the range [0, 53]. Weeks begin with Sunday, and dates prior to the first Sunday of the year are in week 0.
WEEK(<WEEKDAY>): Returns the week number of the date in the range [0, 53]. Weeks begin on WEEKDAY. Dates prior to the first WEEKDAY of the year are in week 0. Valid values for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK: Returns the ISO 8601 week number of the date_expression. ISOWEEKs begin on Monday. Return values are in the range [1, 53]. The first ISOWEEK of each ISO year begins on the Monday before the first Thursday of the Gregorian calendar year.
MONTH
QUARTER: Returns values in the range [1,4].
YEAR
ISOYEAR: Returns the ISO 8601 week-numbering year, which is the Gregorian calendar year containing the Thursday of the week to which date_expression belongs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="EXTRACT",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
    ).exists():
        model(
            name="EXTRACT",
            syntax="EXTRACT(part FROM datetime_expression)",
            description="""Returns a value that corresponds to the specified part from a supplied datetime_expression.

Allowed part values are:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
DAYOFWEEK: Returns values in the range [1,7] with Sunday as the first day of of the week.
DAY
DAYOFYEAR
WEEK: Returns the week number of the date in the range [0, 53]. Weeks begin with Sunday, and dates prior to the first Sunday of the year are in week 0.
WEEK(<WEEKDAY>): Returns the week number of datetime_expression in the range [0, 53]. Weeks begin on WEEKDAY. datetimes prior to the first WEEKDAY of the year are in week 0. Valid values for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK: Returns the ISO 8601 week number of the datetime_expression. ISOWEEKs begin on Monday. Return values are in the range [1, 53]. The first ISOWEEK of each ISO year begins on the Monday before the first Thursday of the Gregorian calendar year.
MONTH
QUARTER
YEAR
ISOYEAR: Returns the ISO 8601 week-numbering year, which is the Gregorian calendar year containing the Thursday of the week to which date_expression belongs.
DATE
TIME""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="EXTRACT",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="EXTRACT",
            syntax="EXTRACT(part FROM time_expression)",
            description="""Returns a value that corresponds to the specified part from a supplied time_expression.

Allowed part values are:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
Returned values truncate lower order time periods. For example, when extracting seconds, EXTRACT truncates the millisecond and microsecond values.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="EXTRACT",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="EXTRACT",
            syntax="EXTRACT(part FROM timestamp_expression [AT TIME ZONE time_zone])",
            description="""Returns a value that corresponds to the specified part from a supplied timestamp_expression. This function supports an optional time_zone parameter. See Time zone definitions for information on how to specify a time zone.

Allowed part values are:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
DAYOFWEEK: Returns values in the range [1,7] with Sunday as the first day of of the week.
DAY
DAYOFYEAR
WEEK: Returns the week number of the date in the range [0, 53]. Weeks begin with Sunday, and dates prior to the first Sunday of the year are in week 0.
WEEK(<WEEKDAY>): Returns the week number of timestamp_expression in the range [0, 53]. Weeks begin on WEEKDAY. datetimes prior to the first WEEKDAY of the year are in week 0. Valid values for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK: Returns the ISO 8601 week number of the datetime_expression. ISOWEEKs begin on Monday. Return values are in the range [1, 53]. The first ISOWEEK of each ISO year begins on the Monday before the first Thursday of the Gregorian calendar year.
MONTH
QUARTER
YEAR
ISOYEAR: Returns the ISO 8601 week-numbering year, which is the Gregorian calendar year containing the Thursday of the week to which date_expression belongs.
DATE
DATETIME
TIME
Returned values truncate lower order time periods. For example, when extracting seconds, EXTRACT truncates the millisecond and microsecond values.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE",
        syntax="DATE(year, month, day)",
        description="""Constructs a DATE from INT64 values representing the year, month, and day.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(name="DATE"),
    ).exists():
        model(
            name="DATE",
            syntax="DATE(year, month, day)",
            description="""Constructs a DATE from INT64 values representing the year, month, and day.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE",
        syntax="DATE(timestamp_expression[, time_zone])",
        description="""Extracts the DATE from a TIMESTAMP expression. It supports an optional parameter to specify a time zone. If no time zone is specified, the default time zone, UTC, is used.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(name="DATE"),
    ).exists():
        model(
            name="DATE",
            syntax="DATE(timestamp_expression[, time_zone])",
            description="""Extracts the DATE from a TIMESTAMP expression. It supports an optional parameter to specify a time zone. If no time zone is specified, the default time zone, UTC, is used.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE",
        syntax="DATE(datetime_expression)",
        description="""Extracts the DATE from a DATETIME expression.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(name="DATE"),
    ).exists():
        model(
            name="DATE",
            syntax="DATE(datetime_expression)",
            description="""Extracts the DATE from a DATETIME expression.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME",
        syntax="DATETIME(year, month, day, hour, minute, second)",
        description="""Constructs a DATETIME object using INT64 values representing the year, month, day, hour, minute, and second.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="DATETIME"
        ),
    ).exists():
        model(
            name="DATETIME",
            syntax="DATETIME(year, month, day, hour, minute, second)",
            description="""Constructs a DATETIME object using INT64 values representing the year, month, day, hour, minute, and second.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME",
        syntax="DATETIME(date_expression[, time_expression])",
        description="""Constructs a DATETIME object using a DATE object and an optional TIME object.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="DATETIME"
        ),
    ).exists():
        model(
            name="DATETIME",
            syntax="DATETIME(date_expression[, time_expression])",
            description="""Constructs a DATETIME object using a DATE object and an optional TIME object.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME",
        syntax="DATETIME(timestamp_expression [, time_zone])",
        description="""Constructs a DATETIME object using a TIMESTAMP object. It supports an optional parameter to specify a time zone. If no time zone is specified, the default time zone, UTC, is used.""",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="DATETIME"
        ),
    ).exists():
        model(
            name="DATETIME",
            syntax="DATETIME(timestamp_expression [, time_zone])",
            description="""Constructs a DATETIME object using a TIMESTAMP object. It supports an optional parameter to specify a time zone. If no time zone is specified, the default time zone, UTC, is used.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE_ADD",
    ).exists():
        model(
            name="DATE_ADD",
            syntax="DATE_ADD(date_expression, INTERVAL int64_expression date_part)",
            description="""Adds a specified time interval to a DATE.

DATE_ADD supports the following date_part values:

DAY
WEEK. Equivalent to 7 DAYs.
MONTH
QUARTER
YEAR""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE_SUB",
    ).exists():
        model(
            name="DATE_SUB",
            syntax="DATE_SUB(date_expression, INTERVAL int64_expression date_part)",
            description="""Subtracts a specified time interval from a DATE.

DATE_SUB supports the following date_part values:

DAY
WEEK. Equivalent to 7 DAYs.
MONTH
QUARTER
YEAR""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE_DIFF",
    ).exists():
        model(
            name="DATE_DIFF",
            syntax="DATE_DIFF(date_expression_a, date_expression_b, date_part)",
            description="""Returns the whole number of specified date_part intervals between two DATE objects (date_expression_a - date_expression_b). If the first DATE is earlier than the second one, the output is negative.

DATE_DIFF supports the following date_part values:

DAY
WEEK This date part begins on Sunday.
WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
MONTH, except when the first two arguments are TIMESTAMP objects.
QUARTER
YEAR
ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE_TRUNC",
    ).exists():
        model(
            name="DATE_TRUNC",
            syntax="DATE_TRUNC(date_expression, date_part)",
            description="""Truncates a DATE value to the granularity of date_part. The DATE value is always rounded to the beginning of date_part, which can be one of the following:

DAY: The day in the Gregorian calendar year that contains the DATE value.
WEEK: The first day of the week in the week that contains the DATE value. Weeks begin on Sundays. WEEK is equivalent to WEEK(SUNDAY).
WEEK(WEEKDAY): The first day of the week in the week that contains the DATE value. Weeks begin on WEEKDAY. WEEKDAY must be one of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, or SATURDAY.
ISOWEEK: The first day of the ISO 8601 week in the ISO week that contains the DATE value. The ISO week begins on Monday. The first ISO week of each ISO year contains the first Thursday of the corresponding Gregorian calendar year.
MONTH: The first day of the month in the month that contains the DATE value.
QUARTER: The first day of the quarter in the quarter that contains the DATE value.
YEAR: The first day of the year in the year that contains the DATE value.
ISOYEAR: The first day of the ISO 8601 week-numbering year in the ISO year that contains the DATE value. The ISO year is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="DATE_FROM_UNIX_DATE",
    ).exists():
        model(
            name="DATE_FROM_UNIX_DATE",
            syntax="DATE_FROM_UNIX_DATE(int64_expression)",
            description="""Interprets int64_expression as the number of days since 1970-01-01.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="LAST_DAY",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
    ).exists():
        model(
            name="LAST_DAY",
            syntax="LAST_DAY(date_expression[, date_part])",
            description="""Returns the last day from a date expression. This is commonly used to return the last day of the month.

You can optionally specify the date part for which the last day is returned. If this parameter is not used, the default value is MONTH. LAST_DAY supports the following values for date_part:

YEAR
QUARTER
MONTH
WEEK. Equivalent to 7 DAYs.
WEEK(<WEEKDAY>). <WEEKDAY> represents the starting day of the week. Valid values are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK. Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
ISOYEAR. Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="LAST_DAY",
        type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
    ).exists():
        model(
            name="LAST_DAY",
            syntax="LAST_DAY(datetime_expression[, date_part])",
            description="""Returns the last day from a datetime expression that contains the date. This is commonly used to return the last day of the month.

You can optionally specify the date part for which the last day is returned. If this parameter is not used, the default value is MONTH. LAST_DAY supports the following values for date_part:

YEAR
QUARTER
MONTH
WEEK. Equivalent to 7 DAYs.
WEEK(<WEEKDAY>). <WEEKDAY> represents the starting day of the week. Valid values are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK. Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
ISOYEAR. Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="PARSE_DATE",
    ).exists():
        model(
            name="PARSE_DATE",
            syntax="PARSE_DATE(format_string, date_string)",
            description="""Converts a string representation of date to a DATE object.

format_string contains the format elements that define how date_string is formatted. Each element in date_string must have a corresponding element in format_string. The location of each element in format_string must match the location of each element in date_string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="UNIX_DATE",
    ).exists():
        model(
            name="UNIX_DATE",
            syntax="UNIX_DATE(date_expression)",
            description="""Returns the number of days since 1970-01-01.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATE"
            ),
        ).save()

    if not model.objects.filter(
        name="FORMAT_DATE",
    ).exists():
        model(
            name="FORMAT_DATE",
            syntax="FORMAT_DATE(format_string, date_expr)",
            description="""Formats the date_expr according to the specified format_string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="FORMAT_DATETIME",
    ).exists():
        model(
            name="FORMAT_DATETIME",
            syntax="FORMAT_DATETIME(format_string, datetime_expression)",
            description="""Formats a DATETIME object according to the specified format_string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATE"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME_ADD",
    ).exists():
        model(
            name="DATETIME_ADD",
            syntax="DATETIME_ADD(datetime_expression, INTERVAL int64_expression part)",
            description="""Adds int64_expression units of part to the DATETIME object.

DATETIME_ADD supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
DAY
WEEK. Equivalent to 7 DAYs.
MONTH
QUARTER
YEAR""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME_SUB",
    ).exists():
        model(
            name="DATETIME_SUB",
            syntax="DATETIME_SUB(datetime_expression, INTERVAL int64_expression part)",
            description="""Subtracts int64_expression units of part from the DATETIME.

DATETIME_SUB supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
DAY
WEEK. Equivalent to 7 DAYs.
MONTH
QUARTER
YEAR""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME_DIFF",
    ).exists():
        model(
            name="DATETIME_DIFF",
            syntax="DATETIME_DIFF(datetime_expression_a, datetime_expression_b, part)",
            description="""Returns the whole number of specified part intervals between two DATETIME objects (datetime_expression_a - datetime_expression_b). If the first DATETIME is earlier than the second one, the output is negative. Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two DATETIME objects would overflow an INT64 value.

DATETIME_DIFF supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
DAY
WEEK: This date part begins on Sunday.
WEEK(<WEEKDAY>): This date part begins on WEEKDAY. Valid values for WEEKDAY are SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY.
ISOWEEK: Uses ISO 8601 week boundaries. ISO weeks begin on Monday.
MONTH, except when the first two arguments are TIMESTAMP objects.
QUARTER
YEAR
ISOYEAR: Uses the ISO 8601 week-numbering year boundary. The ISO year boundary is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="DATETIME_TRUNC",
    ).exists():
        model(
            name="DATETIME_TRUNC",
            syntax="DATETIME_TRUNC(datetime_expression, date_time_part)",
            description="""Truncates a DATETIME value to the granularity of date_time_part. The DATETIME value is always rounded to the beginning of date_time_part, which can be one of the following:

MICROSECOND: If used, nothing is truncated from the value.
MILLISECOND: The nearest lessor or equal millisecond.
SECOND: The nearest lessor or equal second.
MINUTE: The nearest lessor or equal minute.
HOUR: The nearest lessor or equal hour.
DAY: The day in the Gregorian calendar year that contains the DATETIME value.
WEEK: The first day of the week in the week that contains the DATETIME value. Weeks begin on Sundays. WEEK is equivalent to WEEK(SUNDAY).
WEEK(WEEKDAY): The first day of the week in the week that contains the DATETIME value. Weeks begin on WEEKDAY. WEEKDAY must be one of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, or SATURDAY.
ISOWEEK: The first day of the ISO 8601 week in the ISO week that contains the DATETIME value. The ISO week begins on Monday. The first ISO week of each ISO year contains the first Thursday of the corresponding Gregorian calendar year.
MONTH: The first day of the month in the month that contains the DATETIME value.
QUARTER: The first day of the quarter in the quarter that contains the DATETIME value.
YEAR: The first day of the year in the year that contains the DATETIME value.
ISOYEAR: The first day of the ISO 8601 week-numbering year in the ISO year that contains the DATETIME value. The ISO year is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="DATETIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="DATETIME"
            ),
        ).save()

    if not model.objects.filter(
        name="FARM_FINGERPRINT",
    ).exists():
        model(
            name="FARM_FINGERPRINT",
            syntax="FARM_FINGERPRINT(value)",
            description="""Computes the fingerprint of the STRING or BYTES input using the Fingerprint64 function from the open-source FarmHash library. The output of this function for a particular input will never change.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="HASH"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="MD5",
    ).exists():
        model(
            name="MD5",
            syntax="MD5(input)",
            description="""Computes the hash of the input using the MD5 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

This function returns 16 bytes.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="HASH"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="SHA1",
    ).exists():
        model(
            name="SHA1",
            syntax="SHA1(input)",
            description="""Computes the hash of the input using the SHA-1 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

This function returns 20 bytes.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="HASH"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="SHA256",
    ).exists():
        model(
            name="SHA256",
            syntax="SHA256(input)",
            description="""Computes the hash of the input using the SHA-256 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

This function returns 32 bytes.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="HASH"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="SHA512",
    ).exists():
        model(
            name="SHA512",
            syntax="SHA512(input)",
            description="""Computes the hash of the input using the SHA-512 algorithm. The input can either be STRING or BYTES. The string version treats the input as an array of bytes.

This function returns 64 bytes.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="HASH"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BYTES"
            ),
        ).save()

    if not model.objects.filter(
        name="MAKE_INTERVAL",
    ).exists():
        model(
            name="MAKE_INTERVAL",
            syntax="MAKE_INTERVAL(year, month, day, hour, minute, second)",
            description="""Constructs an INTERVAL object using INT64 values representing the year, month, day, hour, minute, and second. All arguments are optional with default value of 0 and can be used as named arguments.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="EXTRACT",
        type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
    ).exists():
        model(
            name="EXTRACT",
            syntax="EXTRACT(part FROM interval_expression)",
            description="""Returns the value corresponding to the specified date part. The part must be one of YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MILLISECOND or MICROSECOND.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="JUSTIFY_DAYS",
    ).exists():
        model(
            name="JUSTIFY_DAYS",
            syntax="JUSTIFY_DAYS(interval_expression)",
            description="""Normalizes the day part of the interval to the range from -29 to 29 by incrementing/decrementing the month or year part of the interval.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="JUSTIFY_HOURS",
    ).exists():
        model(
            name="JUSTIFY_HOURS",
            syntax="JUSTIFY_HOURS(interval_expression)",
            description="""Normalizes the time part of the interval to the range from -23:59:59.999999 to 23:59:59.999999 by incrementing/decrementing the day part of the interval.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="JUSTIFY_INTERVAL",
    ).exists():
        model(
            name="JUSTIFY_INTERVAL",
            syntax="JUSTIFY_INTERVAL(interval_expression)",
            description="""Normalizes the days and time parts of the interval.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="INTERVAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INTERVAL"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_EXTRACT",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="STRING"
        ),
    ).exists():
        model(
            name="JSON_EXTRACT",
            syntax="JSON_EXTRACT(json_string_expr, json_path)",
            description="""Extracts a JSON value, such as an array or object, or a JSON scalar value, such as a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_EXTRACT",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(name="JSON"),
    ).exists():
        model(
            name="JSON_EXTRACT",
            syntax="JSON_EXTRACT(json_expr, json_path)",
            description="""Extracts a JSON value, such as an array or object, or a JSON scalar value, such as a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_QUERY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="STRING"
        ),
    ).exists():
        model(
            name="JSON_QUERY",
            syntax="JSON_QUERY(json_string_expr, json_path)",
            description="""Extracts a JSON value, such as an array or object, or a JSON scalar value, such as a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_QUERY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(name="JSON"),
    ).exists():
        model(
            name="JSON_QUERY",
            syntax="JSON_QUERY(json_expr, json_path)",
            description="""Extracts a JSON value, such as an array or object, or a JSON scalar value, such as a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="JSON"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_EXTRACT_SCALAR",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="STRING"
        ),
    ).exists():
        model(
            name="JSON_EXTRACT_SCALAR",
            syntax="JSON_EXTRACT_SCALAR(json_string_expr[, json_path])",
            description="""Extracts a scalar value and then returns it as a string. A scalar value can represent a string, number, or boolean. Removes the outermost quotes and unescapes the return values.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_VALUE",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="STRING"
        ),
    ).exists():
        model(
            name="JSON_VALUE",
            syntax="JSON_VALUE(json_string_expr[, json_path])",
            description="""Extracts a scalar value and then returns it as a string. A scalar value can represent a string, number, or boolean. Removes the outermost quotes and unescapes the return values.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_EXTRACT_ARRAY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="ARRAY"
        ),
    ).exists():
        model(
            name="JSON_EXTRACT_ARRAY",
            syntax="JSON_EXTRACT_ARRAY(json_string_expr[, json_path])",
            description="""Extracts an array of JSON values, such as arrays or objects, and JSON scalar values, such as strings, numbers, and booleans.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_QUERY_ARRAY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="ARRAY"
        ),
    ).exists():
        model(
            name="JSON_QUERY_ARRAY",
            syntax="JSON_QUERY_ARRAY(json_string_expr[, json_path])",
            description="""Extracts an array of JSON values, such as arrays or objects, and JSON scalar values, such as strings, numbers, and booleans.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_EXTRACT_STRING_ARRAY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="ARRAY"
        ),
    ).exists():
        model(
            name="JSON_EXTRACT_STRING_ARRAY",
            syntax="JSON_EXTRACT_STRING_ARRAY(json_string_expr[, json_path])",
            description="""Extracts an array of scalar values and returns an array of string-formatted scalar values. A scalar value can represent a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_VALUE_ARRAY",
        return_type=apps.get_model("core", "BigQueryDataType").objects.get(
            name="ARRAY"
        ),
    ).exists():
        model(
            name="JSON_VALUE_ARRAY",
            syntax="JSON_VALUE_ARRAY(json_string_expr[, json_path])",
            description="""Extracts an array of scalar values and returns an array of string-formatted scalar values. A scalar value can represent a string, number, or boolean.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="ARRAY"
            ),
        ).save()

    if not model.objects.filter(
        name="JSON_TYPE",
    ).exists():
        model(
            name="JSON_TYPE",
            syntax="JSON_TYPE(json_expr)",
            description="""Takes a JSON expression and returns the type of the outermost JSON value as a SQL STRING. The names of these JSON types can be returned:

object
array
string
number
boolean
null""",
            type=apps.get_model("core", "FunctionType").objects.get(name="JSON"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="ABS",
    ).exists():
        model(
            name="ABS",
            syntax="ABS(X)",
            description="""Computes absolute value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SIGN",
    ).exists():
        model(
            name="SIGN",
            syntax="SIGN(X)",
            description="""Returns -1, 0, or +1 for negative, zero and positive arguments respectively.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="IS_INF",
    ).exists():
        model(
            name="IS_INF",
            syntax="IS_INF(X)",
            description="""Returns TRUE if the value is positive or negative infinity.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="IS_NAN",
    ).exists():
        model(
            name="IS_NAN",
            syntax="IS_NAN(X)",
            description="""Returns TRUE if the value is a NaN value.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BOOL"
            ),
        ).save()

    if not model.objects.filter(
        name="IEEE_DIVIDE",
    ).exists():
        model(
            name="IEEE_DIVIDE",
            syntax="IEEE_DIVIDE(X, Y)",
            description="""Divides X by Y; this function never fails.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="RAND",
    ).exists():
        model(
            name="RAND",
            syntax="RAND()",
            description="""Generates a pseudo-random value of type FLOAT64""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SQRT",
    ).exists():
        model(
            name="SQRT",
            syntax="SQRT(X)",
            description="""Computes the square root of X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="POW",
    ).exists():
        model(
            name="POW",
            syntax="POW(X, Y)",
            description="""Returns the value of X raised to the power of Y.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="EXP",
    ).exists():
        model(
            name="EXP",
            syntax="EXP(X)",
            description="""Computes e to the power of X, also called the natural exponential function.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LN",
    ).exists():
        model(
            name="LN",
            syntax="LN(X)",
            description="""Computes the natural logarithm of X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LOG",
    ).exists():
        model(
            name="LOG",
            syntax="LOG(X [, Y])",
            description="""If only X is present, LOG is a synonym of LN. If Y is also present, LOG computes the logarithm of X to base Y.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LOG10",
    ).exists():
        model(
            name="LOG10",
            syntax="LOG10(X)",
            description="""Similar to LOG, but computes logarithm to base 10.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="GREATEST",
    ).exists():
        model(
            name="GREATEST",
            syntax="GREATEST(X1,...,XN)",
            description="""Returns the greatest value among X1,...,XN.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="LEAST",
    ).exists():
        model(
            name="LEAST",
            syntax="LEAST(X1,...,XN)",
            description="""Returns the least value among X1,...,XN.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="DIV",
    ).exists():
        model(
            name="DIV",
            syntax="DIV(X, Y)",
            description="""Returns the result of integer division of X by Y.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="BIGNUMERIC"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_DIVIDE",
    ).exists():
        model(
            name="SAFE_DIVIDE",
            syntax="SAFE_DIVIDE(X, Y)",
            description="""Equivalent to the division operator (X / Y), but returns NULL if an error occurs, such as a division by zero error.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_MULTIPLY",
    ).exists():
        model(
            name="SAFE_MULTIPLY",
            syntax="SAFE_MULTIPLY(X, Y)",
            description="""Equivalent to the multiplication operator (*), but returns NULL if overflow occurs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_NEGATE",
    ).exists():
        model(
            name="SAFE_NEGATE",
            syntax="SAFE_NEGATE(X)",
            description="""Equivalent to the unary minus operator (-), but returns NULL if overflow occurs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_ADD",
    ).exists():
        model(
            name="SAFE_ADD",
            syntax="SAFE_ADD(X, Y)",
            description="""Equivalent to the addition operator (+), but returns NULL if overflow occurs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SAFE_SUBTRACT",
    ).exists():
        model(
            name="SAFE_SUBTRACT",
            syntax="SAFE_SUBTRACT(X, Y)",
            description="""Returns the result of Y subtracted from X. Equivalent to the subtraction operator (-), but returns NULL if overflow occurs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="MOD",
    ).exists():
        model(
            name="MOD",
            syntax="MOD(X, Y)",
            description="""Modulo function: returns the remainder of the division of X by Y.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ROUND",
    ).exists():
        model(
            name="ROUND",
            syntax="ROUND(X [, N])",
            description="""If only X is present, ROUND rounds X to the nearest integer. If N is present, ROUND rounds X to N decimal places after the decimal point. If N is negative, ROUND will round off digits to the left of the decimal point. Rounds halfway cases away from zero.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="TRUNC",
    ).exists():
        model(
            name="TRUNC",
            syntax="TRUNC(X [, N])",
            description="""If only X is present, TRUNC rounds X to the nearest integer whose absolute value is not greater than the absolute value of X. If N is also present, TRUNC behaves like ROUND(X, N), but always rounds towards zero and never overflows.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CEIL",
    ).exists():
        model(
            name="CEIL",
            syntax="CEIL(X)",
            description="""Returns the smallest integral value that is not less than X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="FLOOR",
    ).exists():
        model(
            name="FLOOR",
            syntax="FLOOR(X)",
            description="""Returns the largest integral value that is not greater than X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="COS",
    ).exists():
        model(
            name="COS",
            syntax="COS(X)",
            description="""Computes the cosine of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="COSH",
    ).exists():
        model(
            name="COSH",
            syntax="COSH(X)",
            description="""Computes the hyperbolic cosine of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ACOS",
    ).exists():
        model(
            name="ACOS",
            syntax="ACOS(X)",
            description="""Computes the principal value of the inverse cosine of X. The return value is in the range [0,].""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ACOSH",
    ).exists():
        model(
            name="ACOSH",
            syntax="ACOSH(X)",
            description="""Computes the inverse hyperbolic cosine of X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="COT",
    ).exists():
        model(
            name="COT",
            syntax="COT(X)",
            description="""Computes the cotangent for the angle of X, where X is specified in radians. X can be any data type that coerces to FLOAT64. Supports the SAFE. prefix.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="COTH",
    ).exists():
        model(
            name="COTH",
            syntax="COTH(X)",
            description="""Computes the hyperbolic cotangent for the angle of X, where X is specified in radians. X can be any data type that coerces to FLOAT64. Supports the SAFE. prefix.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CSC",
    ).exists():
        model(
            name="CSC",
            syntax="CSC(X)",
            description="""Computes the cosecant of the input angle, which is in radians. X can be any data type that coerces to FLOAT64. Supports the SAFE. prefix.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CSCH",
    ).exists():
        model(
            name="CSCH",
            syntax="CSCH(X)",
            description="""Computes the hyperbolic cosecant of the input angle, which is in radians. X can be any data type that coerces to FLOAT64. Supports the SAFE. prefix.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SEC",
    ).exists():
        model(
            name="SEC",
            syntax="SEC(X)",
            description="""Computes the secant for the angle of X, where X is specified in radians. X can be any data type that coerces to FLOAT64.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SECH",
    ).exists():
        model(
            name="SECH",
            syntax="SECH(X)",
            description="""Computes the hyperbolic secant for the angle of X, where X is specified in radians. X can be any data type that coerces to FLOAT64.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SIN",
    ).exists():
        model(
            name="SIN",
            syntax="SIN(X)",
            description="""Computes the sine of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="SINH",
    ).exists():
        model(
            name="SINH",
            syntax="SINH(X)",
            description="""Computes the hyperbolic sine of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ASIN",
    ).exists():
        model(
            name="ASIN",
            syntax="ASIN(X)",
            description="""Computes the principal value of the inverse sine of X. The return value is in the range [-/2,/2]. Generates an error if X is outside of the range [-1, 1].""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ASINH",
    ).exists():
        model(
            name="ASINH",
            syntax="ASINH(X)",
            description="""Computes the inverse hyperbolic sine of X.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="TAN",
    ).exists():
        model(
            name="TAN",
            syntax="TAN(X)",
            description="""Computes the tangent of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="TANH",
    ).exists():
        model(
            name="TANH",
            syntax="TANH(X)",
            description="""Computes the hyperbolic tangent of X where X is specified in radians.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ATAN",
    ).exists():
        model(
            name="ATAN",
            syntax="ATAN(X)",
            description="""Computes the principal value of the inverse tangent of X. The return value is in the range [-/2,/2].""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ATANH",
    ).exists():
        model(
            name="ATANH",
            syntax="ATANH(X)",
            description="""Computes the inverse hyperbolic tangent of X. Generates an error if X is outside of the range [-1, 1].""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="ATAN2",
    ).exists():
        model(
            name="ATAN2",
            syntax="ATAN2(X, Y)",
            description="""Computes the inverse hyperbolic tangent of X. Generates an error if X is outside of the range [-1, 1].""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="CBRT",
    ).exists():
        model(
            name="CBRT",
            syntax="CBRT(X)",
            description="""Computes the cube root of X. X can be any data type that coerces to FLOAT64.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="FLOAT64"
            ),
        ).save()

    if not model.objects.filter(
        name="RANGE_BUCKET",
    ).exists():
        model(
            name="RANGE_BUCKET",
            syntax="RANGE_BUCKET(point, boundaries_array)",
            description="""RANGE_BUCKET scans through a sorted array and returns the 0-based position of the point's upper bound.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="MATHS"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME",
        syntax="TIME(hour, minute, second)",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="TIME",
            syntax="TIME(hour, minute, second)",
            description="""Constructs a TIME object using INT64 values representing the hour, minute, and second.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME",
        syntax="TIME(timestamp, [time_zone])",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="TIME",
            syntax="TIME(timestamp, [time_zone])",
            description="""Constructs a TIME object using a TIMESTAMP object. It supports an optional parameter to specify a time zone. If no time zone is specified, the default time zone, UTC, is used.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME",
        syntax="TIME(datetime)",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="TIME",
            syntax="TIME(datetime)",
            description="""Constructs a TIME object using a DATETIME object.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP",
        syntax="TIMESTAMP(string_expression[, time_zone])",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="TIMESTAMP",
            syntax="TIMESTAMP(string_expression[, time_zone])",
            description="""string_expression[, time_zone]: Converts a STRING expression to a TIMESTAMP data type. string_expression must include a timestamp literal. If string_expression includes a time_zone in the timestamp literal, do not include an explicit time_zone argument.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP",
        syntax="TIMESTAMP(date_expression[, time_zone])",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="TIMESTAMP",
            syntax="TIMESTAMP(date_expression[, time_zone])",
            description="""date_expression[, time_zone]: Converts a DATE object to a TIMESTAMP data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP",
        syntax="TIMESTAMP(datetime_expression[, time_zone])",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="TIMESTAMP",
            syntax="TIMESTAMP(datetime_expression[, time_zone])",
            description="""datetime_expression[, time_zone]: Converts a DATETIME object to a TIMESTAMP data type.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="STRING",
        syntax="STRING(timestamp_expression[, time_zone])",
        type=apps.get_model("core", "FunctionType").objects.get(name="STRING"),
    ).exists():
        model(
            name="STRING",
            syntax="STRING(timestamp_expression[, time_zone])",
            description="""Converts a timestamp_expression to a STRING data type. Supports an optional parameter to specify a time zone.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME_ADD",
    ).exists():
        model(
            name="TIME_ADD",
            syntax="TIME_ADD(time_expression, INTERVAL int64_expression part)",
            description="""Adds int64_expression units of part to the TIME object.

TIME_ADD supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
This function automatically adjusts when values fall outside of the 00:00:00 to 24:00:00 boundary. For example, if you add an hour to 23:30:00, the returned value is 00:30:00.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME_SUB",
    ).exists():
        model(
            name="TIME_SUB",
            syntax="TIME_SUB(time_expression, INTERVAL int64_expression part)",
            description="""Subtracts int64_expression units of part from the TIME object.

TIME_SUB supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR
This function automatically adjusts when values fall outside of the 00:00:00 to 24:00:00 boundary. For example, if you subtract an hour from 00:30:00, the returned value is 23:30:00.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME_DIFF",
    ).exists():
        model(
            name="TIME_DIFF",
            syntax="TIME_DIFF(time_expression_a, time_expression_b, part)",
            description="""Returns the whole number of specified part intervals between two TIME objects (time_expression_a - time_expression_b). If the first TIME is earlier than the second one, the output is negative. Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two TIME objects would overflow an INT64 value.

TIME_DIFF supports the following values for part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="TIME_TRUNC",
    ).exists():
        model(
            name="TIME_TRUNC",
            syntax="TIME_TRUNC(time_expression, time_part)",
            description="""Truncates a TIME value to the granularity of time_part. The TIME value is always rounded to the beginning of time_part, which can be one of the following:

MICROSECOND: If used, nothing is truncated from the value.
MILLISECOND: The nearest lessor or equal millisecond.
SECOND: The nearest lessor or equal second.
MINUTE: The nearest lessor or equal minute.
HOUR: The nearest lessor or equal hour.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIME"
            ),
        ).save()

    if not model.objects.filter(
        name="FORMAT_TIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
    ).exists():
        model(
            name="FORMAT_TIME",
            syntax="FORMAT_TIME(format_string, time_object)",
            description="""Formats a TIME object according to the specified format_string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIME"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="FORMAT_TIME",
        type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
    ).exists():
        model(
            name="FORMAT_TIME",
            syntax="FORMAT_TIME(format_string, time_object)",
            description="""Formats a TIME object according to the specified format_string.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_ADD",
    ).exists():
        model(
            name="TIMESTAMP_ADD",
            syntax="TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)",
            description="""Adds int64_expression units of date_part to the timestamp, independent of any time zone.

TIMESTAMP_ADD supports the following values for date_part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR. Equivalent to 60 MINUTEs.
DAY. Equivalent to 24 HOURs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_SUB",
    ).exists():
        model(
            name="TIMESTAMP_SUB",
            syntax="TIMESTAMP_SUB(timestamp_expression, INTERVAL int64_expression date_part)",
            description="""Subtracts int64_expression units of date_part from the timestamp, independent of any time zone.

TIMESTAMP_SUB supports the following values for date_part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR. Equivalent to 60 MINUTEs.
DAY. Equivalent to 24 HOURs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_DIFF",
    ).exists():
        model(
            name="TIMESTAMP_DIFF",
            syntax="TIMESTAMP_DIFF(timestamp_expression_a, timestamp_expression_b, date_part)",
            description="""Returns the whole number of specified date_part intervals between two TIMESTAMP objects (timestamp_expression_a - timestamp_expression_b). If the first TIMESTAMP is earlier than the second one, the output is negative. Throws an error if the computation overflows the result type, such as if the difference in microseconds between the two TIMESTAMP objects would overflow an INT64 value.

TIMESTAMP_DIFF supports the following values for date_part:

MICROSECOND
MILLISECOND
SECOND
MINUTE
HOUR. Equivalent to 60 MINUTEs.
DAY. Equivalent to 24 HOURs.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_TRUNC",
    ).exists():
        model(
            name="TIMESTAMP_TRUNC",
            syntax="TIMESTAMP_TRUNC(timestamp_expression, date_time_part[, time_zone])",
            description="""Truncates a TIMESTAMP value to the granularity of date_time_part. The TIMESTAMP value is always rounded to the beginning of date_time_part, which can be one of the following:

MICROSECOND: If used, nothing is truncated from the value.
MILLISECOND: The nearest lessor or equal millisecond.
SECOND: The nearest lessor or equal second.
MINUTE: The nearest lessor or equal minute.
HOUR: The nearest lessor or equal hour.
DAY: The day in the Gregorian calendar year that contains the TIMESTAMP value.
WEEK: The first day of the week in the week that contains the TIMESTAMP value. Weeks begin on Sundays. WEEK is equivalent to WEEK(SUNDAY).
WEEK(WEEKDAY): The first day of the week in the week that contains the TIMESTAMP value. Weeks begin on WEEKDAY. WEEKDAY must be one of the following: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, or SATURDAY.
ISOWEEK: The first day of the ISO 8601 week in the ISO week that contains the TIMESTAMP value. The ISO week begins on Monday. The first ISO week of each ISO year contains the first Thursday of the corresponding Gregorian calendar year.
MONTH: The first day of the month in the month that contains the TIMESTAMP value.
QUARTER: The first day of the quarter in the quarter that contains the TIMESTAMP value.
YEAR: The first day of the year in the year that contains the TIMESTAMP value.
ISOYEAR: The first day of the ISO 8601 week-numbering year in the ISO year that contains the TIMESTAMP value. The ISO year is the Monday of the first week whose Thursday belongs to the corresponding Gregorian calendar year.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_SECONDS",
    ).exists():
        model(
            name="TIMESTAMP_SECONDS",
            syntax="TIMESTAMP_SECONDS(int64_expression)",
            description="""Interprets int64_expression as the number of seconds since 1970-01-01 00:00:00 UTC and returns a timestamp.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_MILLIS",
    ).exists():
        model(
            name="TIMESTAMP_MILLIS",
            syntax="TIMESTAMP_MILLIS(int64_expression)",
            description="""Interprets int64_expression as the number of milliseconds since 1970-01-01 00:00:00 UTC and returns a timestamp.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="TIMESTAMP_MILLIS",
    ).exists():
        model(
            name="TIMESTAMP_MILLIS",
            syntax="TIMESTAMP_MICROS(int64_expression)",
            description="""Interprets int64_expression as the number of microseconds since 1970-01-01 00:00:00 UTC and returns a timestamp.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="TIMESTAMP"
            ),
        ).save()

    if not model.objects.filter(
        name="UNIX_SECONDS",
    ).exists():
        model(
            name="UNIX_SECONDS",
            syntax="UNIX_SECONDS(timestamp_expression)",
            description="""Returns the number of seconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="UNIX_MILLIS",
    ).exists():
        model(
            name="UNIX_MILLIS",
            syntax="UNIX_MILLIS(timestamp_expression)",
            description="""Returns the number of milliseconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="UNIX_MICROS",
    ).exists():
        model(
            name="UNIX_MICROS",
            syntax="UNIX_MICROS(timestamp_expression)",
            description="""Returns the number of microseconds since 1970-01-01 00:00:00 UTC. Truncates higher levels of precision.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="TIMESTAMP"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="INT64"
            ),
        ).save()

    if not model.objects.filter(
        name="GENERATE_UUID",
    ).exists():
        model(
            name="GENERATE_UUID",
            syntax="GENERATE_UUID()",
            description="""Returns a random universally unique identifier (UUID) as a STRING. The returned STRING consists of 32 hexadecimal digits in five groups separated by hyphens in the form 8-4-4-4-12. The hexadecimal digits represent 122 random bits and 6 fixed bits, in compliance with RFC 4122 section 4.4. The returned STRING is lowercase.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="UTILITY"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="COALESCE",
    ).exists():
        model(
            name="COALESCE",
            syntax="COALESCE(expr[, ...])",
            description="""Returns the value of the first non-null expression. The remaining expressions are not evaluated. An input expression can be any type. There may be multiple input expression types. All input expressions must be implicitly coercible to a common supertype.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONDITIONAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="IF",
    ).exists():
        model(
            name="IF",
            syntax="IF(expr, true_result, else_result)",
            description="""If expr is true, returns true_result, else returns else_result. else_result is not evaluated if expr is true. true_result is not evaluated if expr is false or NULL.

expr must be a boolean expression. true_result and else_result must be coercible to a common supertype.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONDITIONAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="IFNULL",
    ).exists():
        model(
            name="IFNULL",
            syntax="IFNULL(expr, null_result)",
            description="""If expr is NULL, return null_result. Otherwise, return expr. If expr is not NULL, null_result is not evaluated.

expr and null_result can be any type and must be implicitly coercible to a common supertype. Synonym for COALESCE(expr, null_result).""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONDITIONAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="NULLIF",
    ).exists():
        model(
            name="NULLIF",
            syntax="NULLIF(expr, expr_to_match)",
            description="""Returns NULL if expr = expr_to_match is true, otherwise returns expr.

expr and expr_to_match must be implicitly coercible to a common supertype, and must be comparable.

This expression supports specifying collation.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONDITIONAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()

    if not model.objects.filter(
        name="CASE",
    ).exists():
        model(
            name="CASE",
            syntax="""CASE
  WHEN condition THEN result
  [ ... ]
  [ ELSE else_result ]
  END""",
            description="""Evaluates the condition of each successive WHEN clause and returns the first result where the condition is true; any remaining WHEN clauses and else_result are not evaluated. If all conditions are false or NULL, returns else_result if present; if not present, returns NULL.

condition must be a boolean expression. There may be multiple result types. result and else_result expressions must be implicitly coercible to a common supertype.

This expression supports specifying collation.""",
            type=apps.get_model("core", "FunctionType").objects.get(name="CONDITIONAL"),
            return_type=apps.get_model("core", "BigQueryDataType").objects.get(
                name="STRING"
            ),
        ).save()


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0042_function_functiontype_functiontotasktype_and_more"),
    ]

    operations = [
        migrations.RunPython(addfunctiontypes),
        migrations.RunPython(adddatatypes),
        migrations.RunPython(addfunction),
    ]
